name: Check Database Migrations

on:
  pull_request:
    branches: [main, dev/*]
    paths:
      - 'alembic/versions/**'
      - 'src/dotmac/platform/**/models.py'
      - 'alembic/env.py'
      - 'alembic.ini'

jobs:
  check-migrations:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for migration analysis

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root --with dev

      - name: Install project
        run: poetry install --no-interaction

      - name: Check for multiple migration heads
        run: |
          echo "ğŸ” Checking for multiple migration heads..."
          poetry run alembic heads
          HEAD_COUNT=$(poetry run alembic heads | wc -l)

          if [ $HEAD_COUNT -gt 1 ]; then
            echo "âŒ ERROR: Multiple migration heads detected!"
            echo "This indicates unmerged migration branches."
            echo ""
            echo "Migration heads found:"
            poetry run alembic heads
            echo ""
            echo "To fix this, create a merge migration:"
            echo "  alembic merge heads -m 'Merge migration branches'"
            exit 1
          else
            echo "âœ… Single migration head confirmed"
          fi

      - name: Set up PostgreSQL
        uses: ikalnytskyi/action-setup-postgres@v6
        with:
          username: dotmac
          password: dotmac
          database: dotmac_test
          port: 5432
        id: postgres

      - name: Set up test database environment
        run: |
          echo "DATABASE_URL=${{ steps.postgres.outputs.connection-uri }}" >> $GITHUB_ENV
          echo "DATABASE__URL=${{ steps.postgres.outputs.connection-uri }}" >> $GITHUB_ENV

      - name: Test migration up
        run: |
          echo "ğŸ”„ Testing migrations forward..."
          poetry run alembic upgrade head

          if [ $? -eq 0 ]; then
            echo "âœ… All migrations applied successfully"
          else
            echo "âŒ Migration upgrade failed!"
            exit 1
          fi

      - name: Verify database schema
        run: |
          echo "ğŸ” Verifying database schema..."

          # Check that critical tables exist
          poetry run python - << 'EOF'
          import sys
          from sqlalchemy import create_engine, inspect
          import os

          db_url = os.getenv('DATABASE_URL')
          engine = create_engine(db_url)
          inspector = inspect(engine)

          # Critical tables that must exist
          required_tables = [
              'users',
              'roles',
              'permissions',
              'customers',
              'billing_products',
              'billing_invoices',
          ]

          existing_tables = inspector.get_table_names()
          missing_tables = [t for t in required_tables if t not in existing_tables]

          if missing_tables:
              print(f"âŒ Missing critical tables: {missing_tables}")
              sys.exit(1)
          else:
              print(f"âœ… All {len(required_tables)} critical tables exist")
              print(f"   Total tables in schema: {len(existing_tables)}")
          EOF

      - name: Test migration down
        run: |
          echo "ğŸ”„ Testing migration rollback..."
          poetry run alembic downgrade base

          if [ $? -eq 0 ]; then
            echo "âœ… All migrations rolled back successfully"
          else
            echo "âŒ Migration downgrade failed!"
            exit 1
          fi

      - name: Check migration naming convention
        run: |
          echo "ğŸ” Checking migration naming convention..."

          # Expected format: YYYY_MM_DD_HHMM-description.py or YYYY_MM_DD_HHMM-hash_description.py
          invalid_migrations=$(find alembic/versions -name "*.py" -type f ! -name "__*" | \
            grep -v -E "^alembic/versions/[0-9]{4}_[0-9]{2}_[0-9]{2}_[0-9]{4}.*\.py$" | \
            grep -v -E "^alembic/versions/[0-9]{8}_[0-9]{2}_.*\.py$" || true)

          if [ -n "$invalid_migrations" ]; then
            echo "âš ï¸  Warning: Some migrations don't follow naming convention:"
            echo "$invalid_migrations"
            echo ""
            echo "Recommended format: YYYY_MM_DD_HHMM-module_description.py"
            echo "Example: 2025_10_01_1530-billing_add_refund_tables.py"
          else
            echo "âœ… All migrations follow naming convention"
          fi

      - name: Comment PR with results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Migration Check Results')
            );

            const commentBody = `## ğŸ” Migration Check Results

            **Status**: ${{ job.status }}

            âœ… Single migration head confirmed
            âœ… Migrations apply successfully
            âœ… Database schema verified
            âœ… Migrations rollback successfully

            ---
            *Automated check by GitHub Actions*`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }