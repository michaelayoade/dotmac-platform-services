/**
 * GraphQL-powered service registry hooks
 */

import { useQuery, useSubscription } from '@apollo/client';
import { useCallback, useState } from 'react';
import type { ServiceInfo, ServiceStatus } from '../types';

// GraphQL queries (would be generated by codegen)
const SERVICES_QUERY = `
  query ServicesQuery($status: ServiceStatus, $first: Int, $after: String) {
    services(status: $status, first: $first, after: $after) {
      nodes {
        id
        name
        version
        status
        endpoint
        healthCheckUrl
        tags
        metadata
        registeredAt
        lastHeartbeat
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
        totalCount
      }
    }
  }
`;

const SERVICE_QUERY = `
  query ServiceQuery($serviceId: String!) {
    service(serviceId: $serviceId) {
      id
      name
      version
      status
      endpoint
      healthCheckUrl
      tags
      metadata
      registeredAt
      lastHeartbeat
    }
  }
`;

const SERVICE_HEALTH_SUBSCRIPTION = `
  subscription ServiceHealthStreamSubscription {
    serviceHealthStream {
      serviceName
      status
      message
      lastCheck
      responseTimeMs
    }
  }
`;

export interface UseServiceRegistryGraphQLOptions {
  statusFilter?: ServiceStatus;
  pageSize?: number;
  enableRealTime?: boolean;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

export function useServiceRegistryGraphQL({
  statusFilter,
  pageSize = 50,
  enableRealTime = true,
  autoRefresh = true,
  refreshInterval = 30000, // 30 seconds
}: UseServiceRegistryGraphQLOptions = {}) {
  const [loadingMore, setLoadingMore] = useState(false);

  // Main query for services
  const {
    data: servicesData,
    loading: isLoading,
    error,
    fetchMore,
    refetch,
  } = useQuery(SERVICES_QUERY, {
    variables: {
      status: statusFilter,
      first: pageSize,
    },
    errorPolicy: 'all',
    fetchPolicy: autoRefresh ? 'cache-and-network' : 'cache-first',
    pollInterval: autoRefresh ? refreshInterval : undefined,
  });

  // Real-time health monitoring subscription
  const {
    data: healthData,
    loading: healthLoading,
    error: healthError,
  } = useSubscription(SERVICE_HEALTH_SUBSCRIPTION, {
    skip: !enableRealTime,
    onSubscriptionData: ({ subscriptionData, client }) => {
      if (subscriptionData.data?.serviceHealthStream) {
        const healthUpdate = subscriptionData.data.serviceHealthStream;

        // Update service status in cache
        client.cache.modify({
          fields: {
            services(existing) {
              if (!existing?.nodes) return existing;

              const updatedNodes = existing.nodes.map((service: any) => {
                if (service.name === healthUpdate.serviceName) {
                  return {
                    ...service,
                    status: healthUpdate.status,
                    lastHeartbeat: new Date().toISOString(),
                  };
                }
                return service;
              });

              return {
                ...existing,
                nodes: updatedNodes,
              };
            },
          },
        });
      }
    },
  });

  const services = servicesData?.services?.nodes || [];
  const pageInfo = servicesData?.services?.pageInfo;
  const hasNextPage = pageInfo?.hasNextPage || false;
  const totalServices = pageInfo?.totalCount || 0;

  // Service categorization
  const healthyServices = services.filter((s: ServiceInfo) => s.status === 'healthy');
  const unhealthyServices = services.filter((s: ServiceInfo) =>
    s.status === 'unhealthy' || s.status === 'unknown'
  );
  const startingServices = services.filter((s: ServiceInfo) => s.status === 'starting');

  // Health statistics
  const healthPercentage = totalServices > 0
    ? Math.round((healthyServices.length / totalServices) * 100)
    : 0;

  const loadMore = useCallback(async () => {
    if (!hasNextPage || loadingMore) return;

    setLoadingMore(true);
    try {
      await fetchMore({
        variables: {
          after: pageInfo?.endCursor,
        },
      });
    } catch (error) {
      console.error('Failed to load more services:', error);
    } finally {
      setLoadingMore(false);
    }
  }, [hasNextPage, loadingMore, fetchMore, pageInfo]);

  return {
    // Data
    services,
    healthyServices,
    unhealthyServices,
    startingServices,
    totalServices,
    healthPercentage,

    // Loading states
    isLoading: isLoading && !servicesData,
    isRefreshing: isLoading && !!servicesData,
    loadingMore,
    healthLoading,

    // Pagination
    hasNextPage,
    loadMore,

    // Actions
    refetch,

    // Errors
    error,
    healthError,
  };
}

// Hook for individual service details
export function useService(serviceId: string) {
  const { data, loading, error, refetch } = useQuery(SERVICE_QUERY, {
    variables: { serviceId },
    skip: !serviceId,
    errorPolicy: 'all',
  });

  return {
    service: data?.service,
    isLoading: loading,
    error,
    refetch,
  };
}

// Hook for service health monitoring with history
export function useServiceHealth(serviceName?: string) {
  const [healthHistory, setHealthHistory] = useState<any[]>([]);

  const { data, loading, error } = useSubscription(SERVICE_HEALTH_SUBSCRIPTION, {
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.serviceHealthStream) {
        const healthUpdate = subscriptionData.data.serviceHealthStream;

        // Filter for specific service if provided
        if (!serviceName || healthUpdate.serviceName === serviceName) {
          setHealthHistory(prev => [
            {
              ...healthUpdate,
              timestamp: new Date(),
            },
            ...prev.slice(0, 99), // Keep last 100 health checks
          ]);
        }
      }
    },
  });

  const currentHealth = healthHistory.length > 0 ? healthHistory[0] : null;
  const isHealthy = currentHealth?.status === 'healthy';

  const clearHistory = useCallback(() => {
    setHealthHistory([]);
  }, []);

  return {
    currentHealth,
    healthHistory,
    isHealthy,
    isLoading: loading,
    error,
    clearHistory,
  };
}

// Hook for service discovery with load balancing
export function useServiceDiscovery() {
  const { services, isLoading } = useServiceRegistryGraphQL({
    statusFilter: 'healthy', // Only discover healthy services
  });

  const discoverService = useCallback(
    async (
      serviceName: string,
      options: {
        version?: string;
        region?: string;
        strategy?: 'round-robin' | 'random' | 'least-connections';
      } = {}
    ): Promise<ServiceInfo | null> => {
      const { version, region, strategy = 'round-robin' } = options;

      // Filter services by name and optional criteria
      let candidates = services.filter((s: ServiceInfo) => s.name === serviceName);

      if (version) {
        // Simple version matching - in production, use semver
        candidates = candidates.filter((s: ServiceInfo) => s.version === version);
      }

      if (region) {
        candidates = candidates.filter((s: ServiceInfo) =>
          s.tags?.region === region || s.metadata?.region === region
        );
      }

      if (candidates.length === 0) {
        return null;
      }

      // Apply load balancing strategy
      switch (strategy) {
        case 'random':
          return candidates[Math.floor(Math.random() * candidates.length)];

        case 'round-robin':
          // Simple round-robin based on service ID
          const sortedCandidates = candidates.sort((a, b) => a.id.localeCompare(b.id));
          const index = Math.floor(Date.now() / 1000) % sortedCandidates.length;
          return sortedCandidates[index];

        case 'least-connections':
          // In a real implementation, this would check actual connection counts
          // For now, just return the first service
          return candidates[0];

        default:
          return candidates[0];
      }
    },
    [services]
  );

  const getServiceEndpoint = useCallback((service: ServiceInfo): string => {
    return service.endpoint;
  }, []);

  const createServiceClient = useCallback(
    (service: ServiceInfo) => {
      // Return a configured HTTP client for the service
      return {
        baseURL: service.endpoint,
        get: async (path: string, config?: any) => {
          const response = await fetch(`${service.endpoint}${path}`, {
            method: 'GET',
            ...config,
          });
          return response.json();
        },
        post: async (path: string, data?: any, config?: any) => {
          const response = await fetch(`${service.endpoint}${path}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...config?.headers,
            },
            body: JSON.stringify(data),
            ...config,
          });
          return response.json();
        },
      };
    },
    []
  );

  return {
    discoverService,
    getServiceEndpoint,
    createServiceClient,
    isLoading,
  };
}