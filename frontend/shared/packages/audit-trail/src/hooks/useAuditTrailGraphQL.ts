/**
 * GraphQL-powered audit trail hooks
 */

import { useQuery, useMutation, useSubscription } from '@apollo/client';
import { useCallback, useState } from 'react';
import type { AuditEvent, AuditEventFilter } from '../types';

// These would be generated by GraphQL Code Generator
const AUDIT_EVENTS_QUERY = `
  query AuditEventsQuery($filter: AuditEventFilter, $first: Int, $after: String) {
    auditEvents(filter: $filter, first: $first, after: $after) {
      nodes {
        id
        timestamp
        category
        level
        action
        resource
        actor
        tenantId
        ipAddress
        userAgent
        details
        outcome
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
        totalCount
      }
    }
  }
`;

const LOG_AUDIT_EVENT_MUTATION = `
  mutation LogAuditEventMutation(
    $category: AuditCategory!,
    $level: AuditLevel!,
    $action: String!,
    $resource: String!,
    $details: JSON
  ) {
    logAuditEvent(
      category: $category,
      level: $level,
      action: $action,
      resource: $resource,
      details: $details
    ) {
      id
      timestamp
      category
      level
      action
      resource
      actor
      details
      outcome
    }
  }
`;

const AUDIT_EVENTS_SUBSCRIPTION = `
  subscription AuditEventsStreamSubscription($filter: AuditEventFilter) {
    auditEventsStream(filter: $filter) {
      id
      timestamp
      category
      level
      action
      resource
      actor
      tenantId
      ipAddress
      userAgent
      details
      outcome
    }
  }
`;

export interface UseAuditTrailGraphQLOptions {
  filter?: AuditEventFilter;
  pageSize?: number;
  enableRealTime?: boolean;
  autoRefresh?: boolean;
}

export function useAuditTrailGraphQL({
  filter,
  pageSize = 50,
  enableRealTime = true,
  autoRefresh = true,
}: UseAuditTrailGraphQLOptions = {}) {
  const [loadingMore, setLoadingMore] = useState(false);

  // Main query for audit events
  const {
    data: auditData,
    loading: isLoading,
    error,
    fetchMore,
    refetch,
  } = useQuery(AUDIT_EVENTS_QUERY, {
    variables: {
      filter,
      first: pageSize,
    },
    errorPolicy: 'all',
    fetchPolicy: autoRefresh ? 'cache-and-network' : 'cache-first',
    pollInterval: autoRefresh ? 30000 : undefined,
  });

  // Real-time subscription for new events
  const {
    data: subscriptionData,
    loading: subscriptionLoading,
  } = useSubscription(AUDIT_EVENTS_SUBSCRIPTION, {
    variables: { filter },
    skip: !enableRealTime,
    onSubscriptionData: ({ subscriptionData, client }) => {
      if (subscriptionData.data?.auditEventsStream) {
        const newEvent = subscriptionData.data.auditEventsStream;

        // Update the cache with the new event
        client.cache.modify({
          fields: {
            auditEvents(existing) {
              if (!existing?.nodes) return existing;

              return {
                ...existing,
                nodes: [newEvent, ...existing.nodes],
                pageInfo: {
                  ...existing.pageInfo,
                  totalCount: existing.pageInfo.totalCount + 1,
                },
              };
            },
          },
        });
      }
    },
  });

  // Mutation for logging new events
  const [logEventMutation] = useMutation(LOG_AUDIT_EVENT_MUTATION);

  const events = auditData?.auditEvents?.nodes || [];
  const pageInfo = auditData?.auditEvents?.pageInfo;
  const hasNextPage = pageInfo?.hasNextPage || false;
  const totalCount = pageInfo?.totalCount || 0;

  // Categorized events
  const criticalEvents = events.filter((e: AuditEvent) => e.level === 'CRITICAL');
  const securityEvents = events.filter((e: AuditEvent) =>
    e.category === 'SECURITY_EVENT' || e.category === 'AUTHENTICATION'
  );
  const recentEvents = events.slice(0, 10);

  const loadMore = useCallback(async () => {
    if (!hasNextPage || loadingMore) return;

    setLoadingMore(true);
    try {
      await fetchMore({
        variables: {
          after: pageInfo?.endCursor,
        },
      });
    } catch (error) {
      console.error('Failed to load more events:', error);
    } finally {
      setLoadingMore(false);
    }
  }, [hasNextPage, loadingMore, fetchMore, pageInfo]);

  const logUserAction = useCallback(
    async (action: string, resource: string, details: Record<string, any> = {}) => {
      try {
        await logEventMutation({
          variables: {
            category: 'DATA_ACCESS',
            level: 'INFO',
            action,
            resource,
            details,
          },
          // Optimistic update
          optimisticResponse: {
            logAuditEvent: {
              __typename: 'AuditEvent',
              id: `temp-${Date.now()}`,
              timestamp: new Date().toISOString(),
              category: 'DATA_ACCESS',
              level: 'INFO',
              action,
              resource,
              actor: 'current-user', // Would come from auth context
              details,
              outcome: 'success',
            },
          },
          update: (cache, { data }) => {
            if (data?.logAuditEvent) {
              cache.modify({
                fields: {
                  auditEvents(existing) {
                    if (!existing?.nodes) return existing;

                    return {
                      ...existing,
                      nodes: [data.logAuditEvent, ...existing.nodes],
                      pageInfo: {
                        ...existing.pageInfo,
                        totalCount: existing.pageInfo.totalCount + 1,
                      },
                    };
                  },
                },
              });
            }
          },
        });
      } catch (error) {
        console.error('Failed to log user action:', error);
        throw error;
      }
    },
    [logEventMutation]
  );

  const logSecurityEvent = useCallback(
    async (action: string, severity: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL', details: Record<string, any> = {}) => {
      try {
        await logEventMutation({
          variables: {
            category: 'SECURITY_EVENT',
            level: severity,
            action,
            resource: 'security',
            details,
          },
          optimisticResponse: {
            logAuditEvent: {
              __typename: 'AuditEvent',
              id: `temp-${Date.now()}`,
              timestamp: new Date().toISOString(),
              category: 'SECURITY_EVENT',
              level: severity,
              action,
              resource: 'security',
              actor: 'current-user',
              details,
              outcome: 'success',
            },
          },
        });
      } catch (error) {
        console.error('Failed to log security event:', error);
        throw error;
      }
    },
    [logEventMutation]
  );

  const searchEvents = useCallback(
    async (searchFilter: AuditEventFilter): Promise<AuditEvent[]> => {
      try {
        const { data } = await refetch({
          filter: searchFilter,
          first: pageSize,
        });
        return data?.auditEvents?.nodes || [];
      } catch (error) {
        console.error('Failed to search events:', error);
        return [];
      }
    },
    [refetch, pageSize]
  );

  return {
    // Data
    events,
    criticalEvents,
    securityEvents,
    recentEvents,
    totalCount,

    // Loading states
    isLoading: isLoading && !auditData,
    isRefreshing: isLoading && !!auditData,
    loadingMore,
    subscriptionLoading,

    // Pagination
    hasNextPage,
    loadMore,

    // Actions
    logUserAction,
    logSecurityEvent,
    searchEvents,
    refetch,

    // Error handling
    error,
  };
}

// Hook for individual audit event details
export function useAuditEvent(eventId: string) {
  const AUDIT_EVENT_QUERY = `
    query AuditEventQuery($eventId: String!) {
      auditEvent(eventId: $eventId) {
        id
        timestamp
        category
        level
        action
        resource
        actor
        tenantId
        ipAddress
        userAgent
        details
        outcome
      }
    }
  `;

  const { data, loading, error, refetch } = useQuery(AUDIT_EVENT_QUERY, {
    variables: { eventId },
    skip: !eventId,
  });

  return {
    event: data?.auditEvent,
    isLoading: loading,
    error,
    refetch,
  };
}

// Hook for real-time audit event monitoring
export function useAuditEventStream(filter?: AuditEventFilter) {
  const [events, setEvents] = useState<AuditEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  const { data, loading, error } = useSubscription(AUDIT_EVENTS_SUBSCRIPTION, {
    variables: { filter },
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.auditEventsStream) {
        const newEvent = subscriptionData.data.auditEventsStream;
        setEvents(prev => [newEvent, ...prev.slice(0, 99)]); // Keep last 100 events
      }
    },
    onSubscriptionComplete: () => {
      setIsConnected(false);
    },
  });

  // Track connection status
  React.useEffect(() => {
    if (!loading && !error) {
      setIsConnected(true);
    }
  }, [loading, error]);

  const clearEvents = useCallback(() => {
    setEvents([]);
  }, []);

  return {
    events,
    isConnected,
    isLoading: loading,
    error,
    clearEvents,
  };
}