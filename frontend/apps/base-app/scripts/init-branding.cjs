#!/usr/bin/env node

/**
 * Interactive helper that scaffolds a branding configuration for the base app.
 *
 * Generates a `.env.branding` file (and can optionally append to `.env.local`)
 * with all branding-related environment variables populated.
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const os = require('os');

const PROJECT_ROOT = path.resolve(__dirname, '..');
const BRANDING_ENV_FILE = path.join(PROJECT_ROOT, '.env.branding');
const ENV_LOCAL_FILE = path.join(PROJECT_ROOT, '.env.local');

const DEFAULTS = {
  NEXT_PUBLIC_PRODUCT_NAME: 'DotMac Platform',
  NEXT_PUBLIC_PRODUCT_TAGLINE: 'Reusable SaaS backend and APIs to launch faster.',
  NEXT_PUBLIC_COMPANY_NAME: 'DotMac Platform',
  NEXT_PUBLIC_SUPPORT_EMAIL: 'support@example.com',
  NEXT_PUBLIC_LOGO_LIGHT: '',
  NEXT_PUBLIC_LOGO_DARK: '',
  NEXT_PUBLIC_LOGO_ICON: '',
  NEXT_PUBLIC_FAVICON: '/favicon.ico',
  NEXT_PUBLIC_BRAND_PRIMARY: '#0ea5e9',
  NEXT_PUBLIC_BRAND_PRIMARY_FOREGROUND: '#ffffff',
  NEXT_PUBLIC_BRAND_PRIMARY_HOVER: '#0284c7',
  NEXT_PUBLIC_BRAND_PRIMARY_HOVER_DARK: '#38bdf8',
  NEXT_PUBLIC_BRAND_ACCENT: '#0ea5e9',
  NEXT_PUBLIC_BRAND_ACCENT_FOREGROUND: '#0f172a',
  NEXT_PUBLIC_BRAND_ACCENT_DARK: '#38bdf8',
  NEXT_PUBLIC_BRAND_ACCENT_FOREGROUND_DARK: '#0f172a',
  NEXT_PUBLIC_BRAND_FONT_HEADING: 'Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
  NEXT_PUBLIC_BRAND_FONT_BODY: 'Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
  NEXT_PUBLIC_BRAND_RADIUS_LG: '0.5rem',
  NEXT_PUBLIC_BRAND_RADIUS_MD: '0.375rem',
  NEXT_PUBLIC_BRAND_RADIUS_SM: '0.25rem',
};

const QUESTIONS = [
  { key: 'NEXT_PUBLIC_PRODUCT_NAME', prompt: 'Product name' },
  { key: 'NEXT_PUBLIC_PRODUCT_TAGLINE', prompt: 'Product tagline' },
  { key: 'NEXT_PUBLIC_COMPANY_NAME', prompt: 'Company / parent name' },
  { key: 'NEXT_PUBLIC_SUPPORT_EMAIL', prompt: 'Support email' },
  { key: 'NEXT_PUBLIC_LOGO_LIGHT', prompt: 'Logo (light mode, absolute or public path)' },
  { key: 'NEXT_PUBLIC_LOGO_DARK', prompt: 'Logo (dark mode, absolute or public path)' },
  { key: 'NEXT_PUBLIC_LOGO_ICON', prompt: 'Logo icon (square mark, optional)' },
  { key: 'NEXT_PUBLIC_FAVICON', prompt: 'Favicon path (optional)' },
  { key: 'NEXT_PUBLIC_BRAND_PRIMARY', prompt: 'Primary brand color (#hex, rgb, hsl)' },
  { key: 'NEXT_PUBLIC_BRAND_PRIMARY_FOREGROUND', prompt: 'Primary brand text color' },
  { key: 'NEXT_PUBLIC_BRAND_PRIMARY_HOVER', prompt: 'Primary hover color (light mode)' },
  { key: 'NEXT_PUBLIC_BRAND_PRIMARY_HOVER_DARK', prompt: 'Primary hover color (dark mode)' },
  { key: 'NEXT_PUBLIC_BRAND_ACCENT', prompt: 'Accent color' },
  { key: 'NEXT_PUBLIC_BRAND_ACCENT_FOREGROUND', prompt: 'Accent text color' },
  { key: 'NEXT_PUBLIC_BRAND_ACCENT_DARK', prompt: 'Accent color (dark mode)' },
  { key: 'NEXT_PUBLIC_BRAND_ACCENT_FOREGROUND_DARK', prompt: 'Accent text color (dark mode)' },
  { key: 'NEXT_PUBLIC_BRAND_FONT_HEADING', prompt: 'Heading font stack' },
  { key: 'NEXT_PUBLIC_BRAND_FONT_BODY', prompt: 'Body font stack' },
  { key: 'NEXT_PUBLIC_BRAND_RADIUS_LG', prompt: 'Large radius (e.g. buttons)' },
  { key: 'NEXT_PUBLIC_BRAND_RADIUS_MD', prompt: 'Medium radius (cards)' },
  { key: 'NEXT_PUBLIC_BRAND_RADIUS_SM', prompt: 'Small radius (chips)' },
];

function createInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
  });
}

function askQuestion(rl, prompt, defaultValue) {
  const suffix = defaultValue ? ` [${defaultValue}]` : '';
  return new Promise(resolve => {
    rl.question(`${prompt}${suffix}: `, answer => {
      const value = answer.trim();
      resolve(value || defaultValue || '');
    });
  });
}

async function confirmOverwrite(rl, target) {
  return new Promise(resolve => {
    rl.question(`${target} already exists. Overwrite? (y/N): `, answer => {
      const normalized = answer.trim().toLowerCase();
      resolve(normalized === 'y' || normalized === 'yes');
    });
  });
}

function buildEnvContent(answers) {
  const lines = [
    '# Generated by scripts/init-branding.cjs',
    '# Customize brand identity and design tokens for the base app',
    '',
  ];

  Object.entries(answers).forEach(([key, value]) => {
    lines.push(`${key}=${value}`);
  });

  return lines.join(os.EOL) + os.EOL;
}

async function maybeAppendToEnvLocal(rl, content) {
  if (!fs.existsSync(ENV_LOCAL_FILE)) {
    return;
  }

  const shouldAppend = await new Promise(resolve => {
    rl.question('Append values to existing .env.local as well? (y/N): ', answer => {
      const normalized = answer.trim().toLowerCase();
      resolve(normalized === 'y' || normalized === 'yes');
    });
  });

  if (!shouldAppend) {
    return;
  }

  fs.appendFileSync(ENV_LOCAL_FILE, `${os.EOL}${content}`);
  console.log(`✓ Appended branding variables to ${path.basename(ENV_LOCAL_FILE)}`);
}

async function main() {
  console.log('DotMac Base App — Branding Initializer');
  console.log('Answer the prompts to generate branding environment variables.');
  console.log('');

  const rl = createInterface();

  try {
    if (fs.existsSync(BRANDING_ENV_FILE)) {
      const overwrite = await confirmOverwrite(rl, path.basename(BRANDING_ENV_FILE));
      if (!overwrite) {
        console.log('Aborted. Existing branding file left untouched.');
        rl.close();
        return;
      }
    }

    const answers = {};
    for (const question of QUESTIONS) {
      const value = await askQuestion(rl, question.prompt, DEFAULTS[question.key]);
      answers[question.key] = value;
    }

    const content = buildEnvContent(answers);
    fs.writeFileSync(BRANDING_ENV_FILE, content, 'utf8');

    console.log('');
    console.log(`✓ Branding variables written to ${path.basename(BRANDING_ENV_FILE)}`);
    console.log('   Review the file and copy/merge into your preferred env configuration.');

    await maybeAppendToEnvLocal(rl, content);

    console.log('');
    console.log('Next steps:');
    console.log('  1. restart `pnpm dev` so Next.js picks up the new environment values');
    console.log('  2. (Optional) run `pnpm storybook --smoke-test` to ensure the branding story renders');
  } finally {
    rl.close();
  }
}

main().catch(error => {
  console.error('Branding initializer failed:', error);
  process.exitCode = 1;
});
