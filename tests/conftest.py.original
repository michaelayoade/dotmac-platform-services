"""
Global pytest configuration and fixtures for DotMac Platform Services tests.

This module provides:
- Database fixtures (SQLite for unit tests, PostgreSQL for integration)
- Redis fixtures (fakeredis for unit tests, real Redis for integration)
- Vault fixtures (mocked for unit tests, test instance for integration)
- Authentication fixtures (JWT tokens, users, API keys)
- FastAPI test client fixtures
"""

import asyncio
import os
from collections.abc import AsyncGenerator, Generator
from datetime import datetime, timedelta, UTC
from unittest.mock import Mock, patch
from uuid import uuid4

import fakeredis
import freezegun
import pytest
import pytest_asyncio
from fastapi import FastAPI
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from sqlalchemy.orm import Session, sessionmaker

from dotmac.platform.auth.jwt_service import JWTService

# Import our modules
from dotmac.platform.core import TenantContext
from dotmac.platform.database.base import Base
from dotmac.platform.observability import ObservabilityManager
from dotmac.platform.secrets.manager import SecretsManager

# ============================================================================
# Pytest Configuration
# ============================================================================


def pytest_configure(config):
    """Configure pytest with custom markers."""
    config.addinivalue_line("markers", "unit: Unit tests that don't need external services")
    config.addinivalue_line("markers", "integration: Integration tests that need external services")
    config.addinivalue_line("markers", "e2e: End-to-end tests")
    config.addinivalue_line("markers", "slow: Slow running tests")
    config.addinivalue_line("markers", "auth: Authentication related tests")
    config.addinivalue_line("markers", "observability: Observability related tests")
    config.addinivalue_line("markers", "secrets: Secrets management tests")


# ============================================================================
# Environment Configuration
# ============================================================================


@pytest.fixture(scope="session")
def test_config() -> dict:
    """Provide test configuration."""
    return {
        "environment": "test",
        "database_url": os.getenv("TEST_DATABASE_URL", "sqlite:///:memory:"),
        "redis_url": os.getenv("TEST_REDIS_URL", "redis://localhost:6379/0"),
        "vault_url": os.getenv("TEST_VAULT_URL", "http://localhost:8200"),
        "vault_token": os.getenv("TEST_VAULT_TOKEN", "test-root-token"),
        "jwt_secret": "test-secret-key-for-jwt-signing",
        "jwt_algorithm": "HS256",
        "jwt_expiration": 3600,
    }


# ============================================================================
# Database Fixtures
# ============================================================================


@pytest.fixture(scope="session")
def database_engine(test_config):
    """Create database engine for tests."""
    if "sqlite" in test_config["database_url"]:
        # SQLite for unit tests
        engine = create_engine(
            test_config["database_url"], connect_args={"check_same_thread": False}, echo=False
        )
    else:
        # PostgreSQL for integration tests
        engine = create_engine(test_config["database_url"], echo=False)

    # Create all tables
    Base.metadata.create_all(bind=engine)

    yield engine

    # Cleanup
    Base.metadata.drop_all(bind=engine)
    engine.dispose()


@pytest.fixture(scope="function")
def db_session(database_engine) -> Generator[Session, None, None]:
    """Provide database session for tests."""
    SessionLocal = sessionmaker(bind=database_engine, autocommit=False, autoflush=False)
    session = SessionLocal()

    try:
        yield session
    finally:
        session.rollback()
        session.close()


@pytest_asyncio.fixture(scope="function")
async def async_db_session(test_config) -> AsyncGenerator[AsyncSession, None]:
    """Provide async database session for tests."""
    if "sqlite" in test_config["database_url"]:
        db_url = test_config["database_url"].replace("sqlite://", "sqlite+aiosqlite://")
    else:
        db_url = test_config["database_url"].replace("postgresql://", "postgresql+asyncpg://")

    engine = create_async_engine(db_url, echo=False)
    async_session_maker = async_sessionmaker(engine, expire_on_commit=False)

    async with async_session_maker() as session:
        yield session
        await session.rollback()


# ============================================================================
# Redis Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def redis_client(test_config, request):
    """Provide Redis client for tests."""
    if "integration" in request.keywords:
        # Real Redis for integration tests
        import redis

        client = redis.from_url(test_config["redis_url"])
        client.flushdb()  # Clear test database
        yield client
        client.flushdb()  # Cleanup
        client.close()
    else:
        # Fake Redis for unit tests
        client = fakeredis.FakeRedis()
        yield client
        client.flushdb()


@pytest_asyncio.fixture(scope="function")
async def async_redis_client(test_config, request):
    """Provide async Redis client for tests."""
    if "integration" in request.keywords:
        # Real async Redis for integration tests
        import aioredis

        client = await aioredis.from_url(test_config["redis_url"])
        await client.flushdb()
        yield client
        await client.flushdb()
        await client.close()
    else:
        # Fake async Redis for unit tests
        client = fakeredis.aioredis.FakeRedis()
        yield client
        await client.flushdb()


# ============================================================================
# Vault Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def vault_client(test_config, request):
    """Provide Vault client for tests."""
    if "integration" in request.keywords:
        # Real Vault for integration tests
        import hvac

        client = hvac.Client(url=test_config["vault_url"], token=test_config["vault_token"])
        yield client
    else:
        # Mock Vault for unit tests
        mock_client = Mock()
        mock_client.is_authenticated.return_value = True
        mock_client.secrets.kv.v2.read_secret_version.return_value = {
            "data": {"data": {"key": "value"}}
        }
        yield mock_client


# ============================================================================
# Authentication Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def jwt_service(test_config) -> JWTService:
    """Provide JWT service for tests."""
    with patch.dict(
        os.environ,
        {
            "JWT_SECRET_KEY": test_config["jwt_secret"],
            "JWT_ALGORITHM": test_config["jwt_algorithm"],
        },
    ):
        service = JWTService()
        return service


@pytest.fixture(scope="function")
def test_user() -> dict:
    """Provide test user data."""
    return {
        "id": str(uuid4()),
        "email": "test@example.com",
        "username": "testuser",
        "is_active": True,
        "is_admin": False,
        "tenant_id": str(uuid4()),
        "roles": ["user"],
        "permissions": ["read:profile", "write:profile"],
    }


@pytest.fixture(scope="function")
def admin_user() -> dict:
    """Provide admin user data."""
    return {
        "id": str(uuid4()),
        "email": "admin@example.com",
        "username": "admin",
        "is_active": True,
        "is_admin": True,
        "tenant_id": str(uuid4()),
        "roles": ["admin", "user"],
        "permissions": ["*"],
    }


@pytest.fixture(scope="function")
def access_token(jwt_service, test_user) -> str:
    """Provide valid access token."""
    return jwt_service.create_access_token(
        subject=test_user["id"],
        claims={
            "email": test_user["email"],
            "username": test_user["username"],
            "tenant_id": test_user["tenant_id"],
            "roles": test_user["roles"],
        },
    )


@pytest.fixture(scope="function")
def expired_token(jwt_service, test_user) -> str:
    """Provide expired access token."""
    with freezegun.freeze_time(datetime.now(UTC) - timedelta(hours=2)):
        return jwt_service.create_access_token(
            subject=test_user["id"],
            claims={"email": test_user["email"]},
            expires_delta=timedelta(hours=1),
        )


# ============================================================================
# Tenant Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def tenant_context() -> TenantContext:
    """Provide tenant context for tests."""
    return TenantContext(
        tenant_id=str(uuid4()),
        tenant_name="Test Tenant",
        domain="test.example.com",
        is_active=True,
        metadata={"tier": "premium", "region": "us-east-1"},
    )


# ============================================================================
# FastAPI Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def fastapi_app() -> FastAPI:
    """Provide FastAPI app for tests."""
    app = FastAPI(title="Test App", version="1.0.0", docs_url="/docs", redoc_url="/redoc")

    # Add test routes
    @app.get("/health")
    async def health():
        return {"status": "healthy"}

    @app.get("/protected")
    async def protected():
        return {"message": "This is protected"}

    return app


@pytest.fixture(scope="function")
def test_client(fastapi_app) -> TestClient:
    """Provide test client for FastAPI app."""
    return TestClient(fastapi_app)


# ============================================================================
# Observability Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def observability_manager(test_config) -> ObservabilityManager:
    """Provide ObservabilityManager for tests."""
    manager = ObservabilityManager(
        service_name="test-service",
        environment="test",
        otlp_endpoint=None,  # Disabled for unit tests
        enable_tracing=False,
        enable_metrics=False,
        enable_logging=True,
        enable_performance=False,
        enable_security=False,
    )
    manager.initialize()
    yield manager
    manager.shutdown()


# ============================================================================
# Secrets Manager Fixtures
# ============================================================================


@pytest.fixture(scope="function")
def secrets_manager(vault_client, redis_client) -> SecretsManager:
    """Provide SecretsManager for tests."""
    with patch("dotmac.platform.secrets.manager.hvac") as mock_hvac:
        mock_hvac.Client.return_value = vault_client

        manager = SecretsManager(
            vault_url="http://localhost:8200",
            vault_token="test-token",
            mount_point="secret",
            cache_client=redis_client,
            cache_ttl=60,
        )
        yield manager


# ============================================================================
# Async Fixtures
# ============================================================================


@pytest.fixture(scope="session")
def event_loop():
    """Create event loop for async tests."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# ============================================================================
# Mock External Services
# ============================================================================


@pytest.fixture(scope="function", autouse=True)
def mock_external_services(request):
    """Automatically mock external services for unit tests."""
    if "integration" not in request.keywords and "e2e" not in request.keywords:
        with patch("hvac.Client") as mock_vault, patch("redis.Redis") as mock_redis, patch(
            "requests.post"
        ) as mock_requests:
            # Configure mocks
            mock_vault.return_value.is_authenticated.return_value = True
            mock_redis.return_value = fakeredis.FakeRedis()
            mock_requests.return_value.status_code = 200
            mock_requests.return_value.json.return_value = {"status": "ok"}

            yield
    else:
        # For integration/e2e tests, do not mock external services,
        # but still yield to satisfy pytest's generator fixture contract.
        yield


# ============================================================================
# Test Data Factories
# ============================================================================


@pytest.fixture(scope="function")
def user_factory():
    """Factory for creating test users."""

    def create_user(**kwargs):
        defaults = {
            "id": str(uuid4()),
            "email": f"user_{uuid4().hex[:8]}@example.com",
            "username": f"user_{uuid4().hex[:8]}",
            "is_active": True,
            "is_admin": False,
            "tenant_id": str(uuid4()),
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }
        defaults.update(kwargs)
        return defaults

    return create_user


@pytest.fixture(scope="function")
def api_key_factory():
    """Factory for creating API keys."""

    def create_api_key(**kwargs):
        defaults = {
            "id": str(uuid4()),
            "key": f"sk_test_{uuid4().hex}",
            "name": "Test API Key",
            "scopes": ["read", "write"],
            "expires_at": datetime.now(UTC) + timedelta(days=30),
            "is_active": True,
            "created_at": datetime.now(UTC),
        }
        defaults.update(kwargs)
        return defaults

    return create_api_key
