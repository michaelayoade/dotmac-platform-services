"""
Comprehensive tests for communications task_service module.

Tests Celery tasks without requiring a running worker by mocking appropriately.
"""

import asyncio
import pytest
from datetime import datetime, timezone
from unittest.mock import AsyncMock, Mock, patch, MagicMock
from uuid import uuid4

from dotmac.platform.communications.task_service import (
    BulkEmailJob,
    BulkEmailResult,
    TaskService,
    _run_async,
    _send_email_async,
    _send_email_sync,
    _process_bulk_email_job,
    send_bulk_email_task,
    send_single_email_task,
    get_task_service,
    queue_email,
    queue_bulk_emails,
)
from dotmac.platform.communications.email_service import EmailMessage, EmailResponse


class TestBulkEmailJobModel:
    """Test BulkEmailJob Pydantic model."""

    def test_bulk_email_job_creation(self):
        """Test creating a bulk email job."""
        messages = [
            EmailMessage(to=["user1@example.com"], subject="Test 1"),
            EmailMessage(to=["user2@example.com"], subject="Test 2"),
        ]

        job = BulkEmailJob(name="Test Campaign", messages=messages)

        assert job.name == "Test Campaign"
        assert len(job.messages) == 2
        assert job.status == "queued"
        assert job.id.startswith("bulk_")
        assert isinstance(job.created_at, datetime)

    def test_bulk_email_job_with_custom_id(self):
        """Test job with custom ID."""
        messages = [EmailMessage(to=["test@example.com"], subject="Test")]

        job = BulkEmailJob(id="custom_job_123", name="Campaign", messages=messages)

        assert job.id == "custom_job_123"

    def test_bulk_email_job_validation(self):
        """Test job validation."""
        # Missing required field
        with pytest.raises(Exception):  # Pydantic ValidationError
            BulkEmailJob(messages=[])  # Missing 'name'


class TestBulkEmailResultModel:
    """Test BulkEmailResult Pydantic model."""

    def test_bulk_email_result_creation(self):
        """Test creating a bulk email result."""
        responses = [
            EmailResponse(id="msg1", status="sent", recipients_count=1),
            EmailResponse(id="msg2", status="sent", recipients_count=1),
        ]

        result = BulkEmailResult(
            job_id="job_123",
            status="completed",
            total_emails=2,
            sent_count=2,
            failed_count=0,
            responses=responses,
        )

        assert result.job_id == "job_123"
        assert result.status == "completed"
        assert result.total_emails == 2
        assert result.sent_count == 2
        assert result.failed_count == 0
        assert len(result.responses) == 2


class TestAsyncHelpers:
    """Test async helper functions."""

    @pytest.mark.asyncio
    async def test_run_async_with_coroutine(self):
        """Test _run_async executes a coroutine."""

        async def sample_coro():
            await asyncio.sleep(0.01)
            return "result"

        result = _run_async(sample_coro())
        assert result == "result"

    @pytest.mark.asyncio
    async def test_run_async_with_existing_loop(self):
        """Test _run_async when event loop exists."""

        async def sample_coro():
            return "from_loop"

        # This test runs in an async context, so loop exists
        result = _run_async(sample_coro())
        assert result == "from_loop"

    @pytest.mark.asyncio
    async def test_send_email_async_success(self):
        """Test sending email async successfully."""
        mock_service = AsyncMock()
        mock_response = EmailResponse(id="msg_123", status="success", recipients_count=1)
        mock_service.send_email = AsyncMock(return_value=mock_response)

        message = EmailMessage(to=["test@example.com"], subject="Test")

        result = await _send_email_async(mock_service, message)

        assert result.id == "msg_123"
        assert result.status == "sent"  # Normalized from "success"
        mock_service.send_email.assert_called_once_with(message)

    @pytest.mark.asyncio
    async def test_send_email_async_with_sent_status(self):
        """Test email with 'sent' status is unchanged."""
        mock_service = AsyncMock()
        mock_response = EmailResponse(id="msg_123", status="sent", recipients_count=1)
        mock_service.send_email = AsyncMock(return_value=mock_response)

        message = EmailMessage(to=["test@example.com"], subject="Test")

        result = await _send_email_async(mock_service, message)

        assert result.status == "sent"

    @pytest.mark.asyncio
    async def test_send_email_async_with_failed_status(self):
        """Test email with 'failed' status is unchanged."""
        mock_service = AsyncMock()
        mock_response = EmailResponse(id="msg_123", status="failed", recipients_count=1)
        mock_service.send_email = AsyncMock(return_value=mock_response)

        message = EmailMessage(to=["test@example.com"], subject="Test")

        result = await _send_email_async(mock_service, message)

        assert result.status == "failed"

    @pytest.mark.asyncio
    async def test_send_email_async_exception_handling(self):
        """Test exception handling in _send_email_async."""
        mock_service = AsyncMock()
        mock_service.send_email = AsyncMock(side_effect=Exception("SMTP Error"))

        message = EmailMessage(to=["test@example.com"], subject="Test")

        result = await _send_email_async(mock_service, message)

        assert result.status == "failed"
        assert "Task error" in result.message
        assert result.recipients_count == 1

    def test_send_email_sync(self):
        """Test synchronous email sending wrapper."""
        message = EmailMessage(to=["test@example.com"], subject="Test")

        mock_service = AsyncMock()
        expected_response = EmailResponse(id="msg_123", status="sent", recipients_count=1)
        mock_service.send_email = AsyncMock(return_value=expected_response)

        result = _send_email_sync(mock_service, message)

        assert result.id == "msg_123"
        assert result.status == "sent"


class TestBulkEmailProcessing:
    """Test bulk email processing logic."""

    @pytest.mark.asyncio
    async def test_process_bulk_email_job_success(self):
        """Test processing bulk email job successfully."""
        messages = [
            EmailMessage(to=["user1@example.com"], subject="Test 1"),
            EmailMessage(to=["user2@example.com"], subject="Test 2"),
            EmailMessage(to=["user3@example.com"], subject="Test 3"),
        ]
        job = BulkEmailJob(name="Campaign", messages=messages)

        mock_service = AsyncMock()
        mock_service.send_email = AsyncMock(
            side_effect=[
                EmailResponse(id="msg1", status="sent", recipients_count=1),
                EmailResponse(id="msg2", status="sent", recipients_count=1),
                EmailResponse(id="msg3", status="sent", recipients_count=1),
            ]
        )

        result = await _process_bulk_email_job(job, mock_service)

        assert result.job_id == job.id
        assert result.status == "completed"
        assert result.total_emails == 3
        assert result.sent_count == 3
        assert result.failed_count == 0
        assert len(result.responses) == 3

    @pytest.mark.asyncio
    async def test_process_bulk_email_job_partial_failure(self):
        """Test bulk job with some failures."""
        messages = [
            EmailMessage(to=["user1@example.com"], subject="Test 1"),
            EmailMessage(to=["user2@example.com"], subject="Test 2"),
        ]
        job = BulkEmailJob(name="Campaign", messages=messages)

        mock_service = AsyncMock()
        mock_service.send_email = AsyncMock(
            side_effect=[
                EmailResponse(id="msg1", status="sent", recipients_count=1),
                EmailResponse(id="msg2", status="failed", message="Error", recipients_count=1),
            ]
        )

        result = await _process_bulk_email_job(job, mock_service)

        assert result.total_emails == 2
        assert result.sent_count == 1
        assert result.failed_count == 1
        assert result.status == "completed"  # At least one sent

    @pytest.mark.asyncio
    async def test_process_bulk_email_job_all_failed(self):
        """Test bulk job where all emails fail."""
        messages = [
            EmailMessage(to=["user1@example.com"], subject="Test 1"),
        ]
        job = BulkEmailJob(name="Campaign", messages=messages)

        mock_service = AsyncMock()
        mock_service.send_email = AsyncMock(
            return_value=EmailResponse(
                id="msg1", status="failed", message="Error", recipients_count=1
            )
        )

        result = await _process_bulk_email_job(job, mock_service)

        assert result.sent_count == 0
        assert result.failed_count == 1
        assert result.status == "failed"

    @pytest.mark.asyncio
    async def test_process_bulk_email_job_with_progress_callback(self):
        """Test bulk processing with progress callback."""
        messages = [
            EmailMessage(to=["user1@example.com"], subject="Test 1"),
            EmailMessage(to=["user2@example.com"], subject="Test 2"),
        ]
        job = BulkEmailJob(name="Campaign", messages=messages)

        mock_service = AsyncMock()
        mock_service.send_email = AsyncMock(
            return_value=EmailResponse(id="msg", status="sent", recipients_count=1)
        )

        progress_calls = []

        def progress_callback(completed, total, sent, failed):
            progress_calls.append((completed, total, sent, failed))

        result = await _process_bulk_email_job(job, mock_service, progress_callback)

        # Progress should be called: initial + after each message
        assert len(progress_calls) >= 2
        assert progress_calls[0] == (0, 2, 0, 0)  # Initial
        assert progress_calls[-1] == (2, 2, 2, 0)  # Final


class TestCeleryTasks:
    """Test Celery task functions."""

    def test_send_single_email_task_success(self):
        """Test single email task."""
        with patch(
            "dotmac.platform.communications.task_service.get_email_service"
        ) as mock_get_service:
            mock_service = AsyncMock()
            mock_service.send_email = AsyncMock(
                return_value=EmailResponse(id="msg_123", status="sent", recipients_count=1)
            )
            mock_get_service.return_value = mock_service

            message_data = {"to": ["test@example.com"], "subject": "Test Email"}

            result = send_single_email_task(message_data)

            assert result["id"] == "msg_123"
            assert result["status"] == "sent"

    def test_send_single_email_task_exception(self):
        """Test single email task with exception."""
        with patch(
            "dotmac.platform.communications.task_service.get_email_service"
        ) as mock_get_service:
            mock_get_service.side_effect = Exception("Service error")

            message_data = {"to": ["test@example.com"], "subject": "Test Email"}

            result = send_single_email_task(message_data)

            assert result["status"] == "failed"
            assert "Task failed" in result["message"]

    def test_send_bulk_email_task_success(self):
        """Test bulk email task."""
        with patch(
            "dotmac.platform.communications.task_service.get_email_service"
        ) as mock_get_service:
            mock_service = AsyncMock()
            mock_service.send_email = AsyncMock(
                return_value=EmailResponse(id="msg", status="sent", recipients_count=1)
            )
            mock_get_service.return_value = mock_service

            # Create a mock task with bind
            mock_task = Mock()
            mock_task.update_state = Mock()

            job_data = {
                "id": "job_123",
                "name": "Test Campaign",
                "messages": [{"to": ["test@example.com"], "subject": "Test"}],
                "status": "queued",
                "created_at": datetime.now(timezone.utc).isoformat(),
            }

            # Call the task function with self=mock_task
            result = send_bulk_email_task(mock_task, job_data)

            assert result["job_id"] == "job_123"
            assert result["status"] == "completed"
            assert result["total_emails"] == 1
            assert result["sent_count"] == 1

    def test_send_bulk_email_task_exception(self):
        """Test bulk email task with exception."""
        mock_task = Mock()
        mock_task.update_state = Mock()

        # Invalid job data
        job_data = {"id": "job_123", "messages": []}  # Missing 'name'

        result = send_bulk_email_task(mock_task, job_data)

        assert result["status"] == "failed"
        assert "error_message" in result


class TestTaskService:
    """Test TaskService class."""

    def test_task_service_initialization(self):
        """Test TaskService initialization."""
        service = TaskService()
        assert service.celery is not None

    def test_send_email_async(self):
        """Test queueing single email."""
        with patch(
            "dotmac.platform.communications.task_service.send_single_email_task"
        ) as mock_task:
            mock_result = Mock()
            mock_result.id = "task_123"
            mock_task.delay = Mock(return_value=mock_result)

            service = TaskService()
            message = EmailMessage(to=["test@example.com"], subject="Test")

            task_id = service.send_email_async(message)

            assert task_id == "task_123"
            mock_task.delay.assert_called_once()

    def test_send_bulk_emails_async(self):
        """Test queueing bulk email job."""
        with patch("dotmac.platform.communications.task_service.send_bulk_email_task") as mock_task:
            mock_result = Mock()
            mock_result.id = "task_456"
            mock_task.delay = Mock(return_value=mock_result)

            service = TaskService()
            messages = [EmailMessage(to=["test@example.com"], subject="Test")]
            job = BulkEmailJob(name="Campaign", messages=messages)

            task_id = service.send_bulk_emails_async(job)

            assert task_id == "task_456"
            mock_task.delay.assert_called_once()

    def test_get_task_status(self):
        """Test getting task status."""
        service = TaskService()

        with patch.object(service.celery, "AsyncResult") as mock_async_result:
            mock_result = Mock()
            mock_result.status = "SUCCESS"
            mock_result.result = {"data": "test"}
            mock_result.info = {"progress": 100}
            mock_async_result.return_value = mock_result

            status = service.get_task_status("task_789")

            assert status["task_id"] == "task_789"
            assert status["status"] == "SUCCESS"
            assert status["result"] == {"data": "test"}

    def test_cancel_task_success(self):
        """Test cancelling a task."""
        service = TaskService()

        with patch.object(service.celery.control, "revoke") as mock_revoke:
            mock_revoke.return_value = None

            result = service.cancel_task("task_999")

            assert result is True
            mock_revoke.assert_called_once_with("task_999", terminate=True)

    def test_cancel_task_failure(self):
        """Test cancel task with exception."""
        service = TaskService()

        with patch.object(service.celery.control, "revoke") as mock_revoke:
            mock_revoke.side_effect = Exception("Cancel failed")

            result = service.cancel_task("task_999")

            assert result is False


class TestGlobalServiceInstance:
    """Test global service instance management."""

    def test_get_task_service_singleton(self):
        """Test get_task_service returns singleton."""
        # Reset global
        import dotmac.platform.communications.task_service

        dotmac.platform.communications.task_service._task_service = None

        service1 = get_task_service()
        service2 = get_task_service()

        assert service1 is service2

    def test_get_task_service_creates_instance(self):
        """Test get_task_service creates instance if needed."""
        import dotmac.platform.communications.task_service

        dotmac.platform.communications.task_service._task_service = None

        service = get_task_service()

        assert service is not None
        assert isinstance(service, TaskService)


class TestConvenienceFunctions:
    """Test convenience wrapper functions."""

    def test_queue_email(self):
        """Test queue_email convenience function."""
        with patch("dotmac.platform.communications.task_service.get_task_service") as mock_get:
            mock_service = Mock()
            mock_service.send_email_async = Mock(return_value="task_abc")
            mock_get.return_value = mock_service

            task_id = queue_email(
                to=["user@example.com"], subject="Hello", text_body="Test message"
            )

            assert task_id == "task_abc"
            mock_service.send_email_async.assert_called_once()

    def test_queue_bulk_emails(self):
        """Test queue_bulk_emails convenience function."""
        with patch("dotmac.platform.communications.task_service.get_task_service") as mock_get:
            mock_service = Mock()
            mock_service.send_bulk_emails_async = Mock(return_value="task_def")
            mock_get.return_value = mock_service

            messages = [
                EmailMessage(to=["user1@example.com"], subject="Test 1"),
                EmailMessage(to=["user2@example.com"], subject="Test 2"),
            ]

            task_id = queue_bulk_emails(name="Campaign", messages=messages)

            assert task_id == "task_def"
            mock_service.send_bulk_emails_async.assert_called_once()


class TestProgressTracking:
    """Test progress tracking in bulk jobs."""

    def test_bulk_task_progress_updates(self):
        """Test that progress is tracked during bulk processing."""
        with patch(
            "dotmac.platform.communications.task_service.get_email_service"
        ) as mock_get_service:
            mock_service = AsyncMock()
            # Return success for all emails
            mock_service.send_email = AsyncMock(
                return_value=EmailResponse(id="msg", status="sent", recipients_count=1)
            )
            mock_get_service.return_value = mock_service

            mock_task = Mock()
            update_states = []

            def capture_state(state, meta):
                update_states.append((state, meta))

            mock_task.update_state = Mock(side_effect=capture_state)

            # Create job with 12 messages to trigger progress logging at 10-message intervals
            messages = [
                EmailMessage(to=[f"user{i}@example.com"], subject=f"Test {i}") for i in range(12)
            ]
            job_data = {
                "id": "job_progress",
                "name": "Progress Test",
                "messages": [m.model_dump() for m in messages],
                "status": "queued",
                "created_at": datetime.now(timezone.utc).isoformat(),
            }

            result = send_bulk_email_task(mock_task, job_data)

            assert result["sent_count"] == 12
            # Progress updates should have been called
            assert len(update_states) > 0
            # Final state should be SUCCESS
            final_state, final_meta = update_states[-1]
            assert final_state == "SUCCESS"
            assert final_meta["sent"] == 12
